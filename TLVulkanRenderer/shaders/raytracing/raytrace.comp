// Shader is looseley based on the ray tracing coding session by Inigo Quilez (www.iquilezles.org)

#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform writeonly image2D resultImage;

#define EPSILON 0.0001
#define MAXLEN 1000.0
#define SHADOW 0.5
#define RAYBOUNCES 2
#define REFLECTIONS true
#define REFLECTIONSTRENGTH 0.4
#define REFLECTIONFALLOFF 0.5

struct Camera 
{
	vec3 pos;   
	vec3 lookat;
	float fov; 
};

layout (binding = 1) uniform UBO 
{
	vec3 lightPos;
	float aspectRatio;
	Camera camera;
} ubo;

struct Triangle
{
	int materialId;
	vec3 vert0;
	vec3 vert1;
	vec3 vert2;
	vec3 norm0;
	vec3 norm1;
	vec3 norm2;
};

struct Plane
{
	vec3 normal;
	float distance;
	vec3 diffuse;
	float specular;
	int id;
};

layout (std140, binding = 2) buffer Planes
{
	Plane planes[ ];
};

void reflectRay(inout vec3 rayD, in vec3 mormal)
{
	rayD = rayD + 2.0 * -dot(mormal, rayD) * mormal;
}

// Lighting =========================================================

float lightDiffuse(vec3 normal, vec3 lightDir) 
{
	return clamp(dot(normal, lightDir), 0.1, 1.0);
}

float lightSpecular(vec3 normal, vec3 lightDir, float specularFactor)
{
	vec3 viewVec = normalize(ubo.camera.pos);
	vec3 halfVec = normalize(lightDir + viewVec);
	return pow(clamp(dot(normal, halfVec), 0.0, 1.0), specularFactor);
}

// Plane ===========================================================
	
int intersect(in vec3 rayO, in vec3 rayD, inout float resT)
{
	int id = -1;

	for (int i = 0; i < planes.length(); i++)
	{
		float tplane = 0.0;
		float d = dot(rayD, planes[i].normal);
		if (d != 0.0) {
			
			float t = -(planes[i].distance + dot(rayO, planes[i].normal)) / d;

			if (t > 0.0) {
				tplane = t;
			}
		}

		if ((tplane > EPSILON) && (tplane < resT))
		{
			id = planes[i].id;
			resT = tplane;
		}	
	}
	
	return id;
}

vec3 renderScene(inout vec3 rayO, inout vec3 rayD, inout int id)
{
	vec3 color = vec3(0.0);
	float t = MAXLEN;

	// Get intersected object ID
	int objectID = intersect(rayO, rayD, t);
	
	if (objectID == -1)
	{
		return color;
	}
	
	vec3 pos = rayO + t * rayD;
	vec3 lightVec = normalize(ubo.lightPos - pos);				
	vec3 normal;

	// Planes

	for (int i = 0; i < planes.length(); i++)
	{
		if (objectID == planes[i].id)
		{
			normal = planes[i].normal;
			float diffuse = lightDiffuse(normal, lightVec);
			float specular = lightSpecular(normal, lightVec, planes[i].specular);
			color = diffuse * planes[i].diffuse + specular;	
		}
	}

	if (id == -1)
		return color;

	id = objectID;

	t = length(ubo.lightPos - pos);

	// Reflect ray for next render pass
	reflectRay(rayD, normal);
	rayO = pos;	
	
	return color;
}

void main()
{
	//ivec2 dim = imageSize(resultImage);
	//vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

	//vec3 rayO = ubo.camera.pos;
	//vec3 rayD = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ubo.aspectRatio, 1.0), -1.0));
		
	//// Basic color path
	//int id = 0;
	//vec3 finalColor = renderScene(rayO, rayD, id);
	
	//// Reflection
	//if (REFLECTIONS)
	//{
	//	float reflectionStrength = REFLECTIONSTRENGTH;
	//	for (int i = 0; i < RAYBOUNCES; i++)
	//	{
	//		vec3 reflectionColor = renderScene(rayO, rayD, id);
	//		finalColor = (1.0 - reflectionStrength) * finalColor + reflectionStrength * mix(reflectionColor, finalColor, 1.0 - reflectionStrength);			
	//		reflectionStrength *= REFLECTIONFALLOFF;
	//	}
	//}

	vec3 finalColor = vec3(1, 1, 0);
			
	imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(finalColor, 0.0));
}
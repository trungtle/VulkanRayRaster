// Shader is looseley based on the ray tracing coding session by Inigo Quilez (www.iquilezles.org)

#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform writeonly image2D resultImage;

#define EPSILON 0.000001
#define MAXLEN 1000.0
#define RAYBOUNCES 2
#define REFLECTIONS false
#define REFLECTIONSTRENGTH 0.4
#define REFLECTIONFALLOFF 0.5

struct Camera 
{
	float aspectRatio;
	vec3 position;   
	vec3 lookat;
	vec3 forward;
	vec3 right;
	vec3 up;
	float fov;
	vec2 pixelLength; 
};

layout (binding = 1) uniform UBO 
{
	vec3 lightPos;
	Camera camera;
} ubo;

struct Triangle
{
	int id;
	int materialId;
	vec3 vert0;
	vec3 vert1;
	vec3 vert2;
	vec3 norm0;
	vec3 norm1;
	vec3 norm2;
};

struct Ray
{
	vec3 origin;
	vec3 direction;
};

struct Plane
{
	vec3 normal;
	float distance;
	vec3 diffuse;
	float specular;
	int id;
};

layout (std140, binding = 2) buffer Planes
{
	Plane planes[ ];
};

void reflectRay(inout vec3 rayD, in vec3 mormal)
{
	rayD = rayD + 2.0 * -dot(mormal, rayD) * mormal;
}

// Lighting =========================================================

float lightDiffuse(vec3 normal, vec3 lightDir) 
{
	return clamp(dot(normal, lightDir), 0.1, 1.0);
}

float lightSpecular(vec3 normal, vec3 lightDir, float specularFactor)
{
	vec3 viewVec = normalize(ubo.camera.position);
	vec3 halfVec = normalize(lightDir + viewVec);
	return pow(clamp(dot(normal, halfVec), 0.0, 1.0), specularFactor);
}


// Triangle ===========================================================

vec3 testColor = vec3(1,1,1);
vec3 rayOrigin = vec3(0,0,10);

float triangleIntersect(
	in Triangle tri, 
	in Ray r
	) 
{
	// Compute fast intersection using Muller and Trumbore, this skips computing the plane's equation.
	// See https://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf

	float t = -1.0;
	
	// Find the edges that share vertice 0
	vec3 edge1 = tri.vert0 - tri.vert1;
	vec3 edge2 = tri.vert2 - tri.vert0;

	// Being computing determinante. Store pvec for recomputation
	vec3 pvec = cross(r.direction, edge2);
	// If determinant is 0, ray lies in plane of triangle
	float det = dot(pvec, edge1);
	if (abs(det) < EPSILON) {
		return -1;
	}
	float inv_det = 1.0 / det;
	vec3 tvec = vec3(0,0,10) - tri.vert0;

	// u, v are the barycentric coordinates of the intersection point in the triangle
	// t is the distance between the ray's origin and the point of intersection
	float u, v;

	// Compute u
	u = dot(pvec, tvec) * inv_det;
	if (u < 0.0f || u > 1.0) {
		return -1;
	}

	// Compute v
	vec3 qvec = cross(tvec, edge1);
	v = dot(r.direction, qvec) * inv_det;
	if (v < 0.0 || (u + v) > 1.0) {
		return -1;
	}

	// Compute t
	t = dot(edge2, qvec) * inv_det;
	//t = dot(edge2, qvec);
	if (dot(edge2, qvec) < EPSILON) {
		testColor = normalize(edge1);
		testColor = qvec;
	}
	// Interpolate the normal
	vec3 objspaceNormal = normalize(tri.norm0 * (1 - u - v) + tri.norm1 * u + tri.norm2 * v);

	return t;
}


// Intersection ===========================================================
	
int intersect(in Ray ray, inout float resT)
{
	int id = -1;

	Triangle tri;
	tri.id = 0;
	tri.materialId = 0;
	tri.vert0 = vec3(-1.0, 0.0, 0.0);
	tri.vert1 = vec3(0.0, -1.0, 0.0);
	tri.vert2 = vec3(1.0, 0.0, 0.0);
	tri.norm0 = vec3(0, 0, 1);
	tri.norm1 = vec3(0, 0, 1);
	tri.norm2 = vec3(0, 0, 1);

	float tTri = triangleIntersect(tri, ray);
	if ((tTri > EPSILON) && (tTri < resT))
	{
		id = tri.id;
		resT = tTri;
	}
	
	return id;
}

vec3 renderScene(inout Ray ray)
{
	vec3 color = vec3(0.0);
	float t = MAXLEN;

	// Get intersected object ID
	int objectID = intersect(ray, t);
	
	if (objectID == -1)
	{
		return color;
	}
	
	vec3 pos = rayOrigin + t * ray.direction;
	vec3 lightVec = normalize(ubo.lightPos - pos);				
	vec3 normal;

	// Triangle

	if (objectID == 0) {
		normal = vec3(0, 0, 1);
		float diffuse = lightDiffuse(normal, lightVec);
		color = vec3(1, 1, 0);	
	}

	// Reflect ray for next render pass
	reflectRay(ray.direction, normal);
	ray.origin = pos;	
	
	return color;
}

// Generate ray ========================

void castRayFromCamera(in int width, in int height, inout Ray ray) 
{
	uint x = gl_GlobalInvocationID.x;
	uint y =  gl_GlobalInvocationID.y;
	if (x < width && y < height) {
		ray.origin = rayOrigin;//ubo.camera.position;
		ray.direction = normalize(
			ubo.camera.forward 
			- ubo.camera.right * ubo.camera.pixelLength.x * (float(x) - float(width) * 0.5)
			- ubo.camera.up * ubo.camera.pixelLength.y * (float(y) - float(height) * 0.5)
			);
		ray.direction = normalize(vec3(float(width) * 0.5 - float(x), float(height) * 0.5 - float(y), 1000.0));
	}
}

void main()
{
	ivec2 dim = imageSize(resultImage);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

	Ray ray;
	castRayFromCamera(dim.x, dim.y, ray);		

	// Basic color path
	int id = 0;
	vec3 finalColor = renderScene(ray);
	
	// Reflection
	if (REFLECTIONS)
	{
		float reflectionStrength = REFLECTIONSTRENGTH;
		for (int i = 0; i < RAYBOUNCES; i++)
		{
			vec3 reflectionColor = renderScene(ray);
			finalColor = (1.0 - reflectionStrength) * finalColor + reflectionStrength * mix(reflectionColor, finalColor, 1.0 - reflectionStrength);			
			reflectionStrength *= REFLECTIONFALLOFF;
		}
	}
	
	finalColor = testColor;

	imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(finalColor, 0.0));
}